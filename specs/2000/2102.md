---
# ============================================================================
# SPEC METADATA - This entire frontmatter section contains the spec metadata
# ============================================================================

# === IDENTIFICATION ===
id: '2102' # Numeric ID for stable reference
title: 'KIS WebSocket Real-time Data Integration'
type: 'feature' # prd | epic | feature | task | subtask | bug | spike

# === HIERARCHY ===
parent: '2000' # Parent spec ID (broker integration epic)
children: [] # Child spec IDs (if any)
epic: '2000' # Root epic ID for this work
domain: 'broker-kis-realtime' # Business domain

# === WORKFLOW ===
status: 'draft' # draft | reviewing | approved | in-progress | testing | done
priority: 'high' # high | medium | low

# === TRACKING ===
created: '2025-08-25' # YYYY-MM-DD
updated: '2025-08-25' # YYYY-MM-DD
due_date: '' # YYYY-MM-DD (optional)
estimated_hours: 30 # Time estimate in hours
actual_hours: 0 # Time spent so far

# === DEPENDENCIES ===
dependencies: ['2101'] # Must be done before this (KIS REST API)
blocks: [] # This blocks nothing
related: ['2104', '2110'] # Related to rate limiting and monitoring

# === IMPLEMENTATION ===
branch: '' # Git branch name
files: ['apps/brokers/kis/websocket/', 'libs/shared/services/kis-websocket.service.ts'] # Key files to modify

# === METADATA ===
tags: ['kis', 'websocket', 'real-time', 'market-data', 'streaming'] # Searchable tags
effort: 'medium' # small | medium | large | epic
risk: 'medium' # low | medium | high (real-time connectivity challenges)

# ============================================================================
---

# KIS WebSocket Real-time Data Integration

## Overview

Implement WebSocket integration for KIS real-time market data streaming with connection management, subscription handling, and data normalization. This feature enables real-time price updates, orderbook changes, and trade execution notifications through KIS's WebSocket API, supporting up to 5 concurrent connections with 40 symbols per connection for a total of 200 real-time symbol subscriptions.

## Acceptance Criteria

- [ ] WebSocket connection management with auto-reconnection implemented
- [ ] Support for 5 concurrent WebSocket connections
- [ ] Symbol subscription management (40 symbols per connection)
- [ ] Real-time price tick processing with <10ms latency
- [ ] Orderbook depth updates (10 levels) in real-time
- [ ] Trade execution notifications processed immediately
- [ ] Connection pooling with intelligent symbol distribution
- [ ] Heartbeat mechanism with 30-second timeout detection
- [ ] Automatic failover and resubscription on connection loss
- [ ] Data normalization to unified format
- [ ] Ring buffer implementation for tick data storage
- [ ] WebSocket authentication with token management
- [ ] Both production and sandbox WebSocket support
- [ ] Performance metrics collection and monitoring

## Technical Approach

### WebSocket Architecture

Implement a robust WebSocket client that manages multiple concurrent connections to KIS WebSocket servers, handles real-time data streams, and provides reliable data delivery with automatic recovery mechanisms.

### Key Components

1. **Connection Manager**
   - WebSocket client pool (5 connections max)
   - Connection state tracking
   - Auto-reconnection with exponential backoff
   - Load balancing across connections
   - Health monitoring per connection

2. **Subscription Manager**
   - Symbol allocation strategy (40 per connection)
   - Dynamic subscription/unsubscription
   - Symbol redistribution on connection changes
   - Subscription state persistence
   - Priority-based symbol allocation

3. **Data Processing Pipeline**
   - Binary/JSON message parsing
   - Data decompression if needed
   - Type-specific handlers (price, orderbook, trades)
   - Data validation and sanitization
   - Timestamp synchronization

4. **Message Handlers**
   - Price tick processor
   - Orderbook update handler
   - Trade execution processor
   - System message handler
   - Error message processor

5. **Data Distribution**
   - Ring buffer for tick storage
   - Event emitter for subscribers
   - Data caching layer
   - Backpressure handling
   - Message queuing

### Implementation Steps

1. **Setup WebSocket Infrastructure**
   - Create WebSocket service in NestJS
   - Implement connection factory
   - Configure WebSocket client options
   - Setup connection pool management
   - Add connection monitoring

2. **Implement Authentication**
   - WebSocket token generation
   - Authentication message handling
   - Token refresh coordination
   - Session management
   - Credential rotation support

3. **Build Subscription System**
   - Symbol subscription protocol
   - Subscription queue management
   - Symbol-to-connection mapping
   - Resubscription on reconnect
   - Subscription confirmation handling

4. **Create Data Processors**
   - Message type detection
   - Price tick normalization
   - Orderbook reconstruction
   - Trade data parsing
   - Data validation pipeline

5. **Develop Recovery Mechanisms**
   - Connection failure detection
   - Automatic reconnection logic
   - State recovery after reconnect
   - Data gap detection
   - Backfill coordination with REST API

6. **Add Monitoring & Metrics**
   - Connection status tracking
   - Data rate monitoring
   - Latency measurement
   - Error rate tracking
   - Performance dashboards

## WebSocket Specifications

### Connection Details
- **Production**: `ws://ops.koreainvestment.com:21000`
- **Sandbox**: `ws://ops.koreainvestment.com:31000`
- **Max Connections**: 5 concurrent
- **Symbols per Connection**: 40 maximum
- **Total Symbol Capacity**: 200 (5 Ã— 40)

### Message Types
- **Price Updates**: Real-time price changes
- **Orderbook**: Bid/ask depth updates
- **Trades**: Executed trade notifications
- **System**: Connection status, errors
- **Heartbeat**: Keep-alive messages

### Performance Requirements
- **Message Processing**: <10ms per tick
- **Reconnection Time**: <5 seconds
- **Data Delivery**: 99.9% reliability
- **Memory Usage**: <100MB for full capacity

## Trading-Specific Requirements

### Real-time Data Processing
- Sub-second price update handling for momentum strategies
- Orderbook reconstruction for market making
- Trade execution monitoring for position tracking
- Volume surge detection for liquidity analysis
- Spread monitoring for arbitrage opportunities

### Connection Reliability
- Heartbeat monitoring every 30 seconds
- Stale data detection and alerting
- Connection quality metrics tracking
- Automatic symbol redistribution on failure
- Priority reconnection for critical symbols

### Data Quality
- Price sanity checks (>10% moves flagged)
- Sequence number validation
- Duplicate message detection
- Gap detection and recovery
- Timestamp accuracy validation

## Dependencies

- **2101**: KIS REST API Integration - Requires REST API for authentication and gap filling
- **2104**: Rate Limiting System - Coordinates with rate limiter for subscription management
- **2110**: Monitoring - Integrates with monitoring for real-time metrics

## Testing Plan

- Unit tests for all message processors
- Integration tests with KIS sandbox WebSocket
- Connection failure simulation tests
- Load testing with maximum symbol capacity
- Latency benchmarks under various conditions
- Memory leak detection over extended runs
- Concurrent connection stress tests
- Data accuracy validation tests
- Recovery mechanism testing

## Claude Code Instructions

```
When implementing this feature:
1. Use ws or socket.io-client for WebSocket connections
2. Implement connection pooling with proper resource management
3. Use RxJS for reactive data stream processing
4. Create ring buffers with fixed size for tick data
5. Implement exponential backoff: 1s, 2s, 4s, 8s, 16s, 32s max
6. Use event emitters for data distribution
7. Add comprehensive logging for debugging
8. Monitor memory usage and implement cleanup
9. Use TypeScript discriminated unions for message types
10. Implement proper error boundaries
11. Add health check endpoints for each connection
12. Use Redis for subscription state persistence
13. Test with network failure scenarios
```

## Notes

- WebSocket has different URLs for production and sandbox
- 40-symbol limit per connection is strict - exceeding causes disconnection
- Heartbeat is critical - missing heartbeats indicate connection issues
- Some data may arrive compressed - implement decompression
- WebSocket tokens differ from REST API tokens
- Connection quality varies with network conditions
- Consider implementing local caching for frequently accessed data

## Status Updates

- **2025-08-25**: Feature spec created and documented