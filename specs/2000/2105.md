---
# ============================================================================
# SPEC METADATA - This entire frontmatter section contains the spec metadata
# ============================================================================

# === IDENTIFICATION ===
id: '2105' # Numeric ID for stable reference
title: 'Multi-Account Pool Management System'
type: 'feature' # prd | epic | feature | task | subtask | bug | spike

# === HIERARCHY ===
parent: '2000' # Parent spec ID (broker integration epic)
children: [] # Child spec IDs (if any)
epic: '2000' # Root epic ID for this work
domain: 'account-management' # Business domain

# === WORKFLOW ===
status: 'draft' # draft | reviewing | approved | in-progress | testing | done
priority: 'high' # high | medium | low

# === TRACKING ===
created: '2025-08-25' # YYYY-MM-DD
updated: '2025-08-25' # YYYY-MM-DD
due_date: '' # YYYY-MM-DD (optional)
estimated_hours: 35 # Time estimate in hours
actual_hours: 0 # Time spent so far

# === DEPENDENCIES ===
dependencies: ['2100', '2104'] # Unified interface and rate limiting
blocks: ['2106'] # Blocks smart order routing
related: ['2101', '2107'] # Related to KIS and service endpoints

# === IMPLEMENTATION ===
branch: '' # Git branch name
files: ['libs/shared/services/account-pool.service.ts', 'apps/brokers/common/account-manager/', 'libs/shared/models/account.model.ts'] # Key files to modify

# === METADATA ===
tags: ['account-pool', 'multi-account', 'load-balancing', 'trading'] # Searchable tags
effort: 'large' # small | medium | large | epic
risk: 'medium' # low | medium | high (complexity in coordination)

# ============================================================================
---

# Multi-Account Pool Management System

## Overview

Implement a dynamic account allocation and management system for distributing trading load across multiple broker accounts. This feature enables intelligent symbol distribution, load balancing, and failover capabilities while maintaining consolidated portfolio views and respecting individual account limits. The system maximizes trading capacity by leveraging multiple accounts to circumvent per-account rate limits and position restrictions.

## Acceptance Criteria

- [ ] Account pool architecture with dynamic registration
- [ ] Symbol distribution strategy across accounts implemented
- [ ] Real-time balance aggregation across all accounts
- [ ] Dynamic account allocation based on available resources
- [ ] Account health monitoring with status tracking
- [ ] Automatic failover for unavailable accounts
- [ ] Load balancing algorithms for optimal distribution
- [ ] Position limit enforcement per account
- [ ] Consolidated portfolio view across accounts
- [ ] Account selection optimization (<10ms)
- [ ] Cross-account synchronization every 5 seconds
- [ ] Account isolation to prevent cascade failures
- [ ] Regulatory compliance for multi-account operations
- [ ] Comprehensive audit trail per account

## Technical Approach

### Account Pool Architecture

Design a sophisticated account management system that treats multiple trading accounts as a unified resource pool, intelligently distributing operations while maintaining individual account integrity and compliance.

### Key Components

1. **Account Registry**
   - Account registration and discovery
   - Credential management per account
   - Account type classification
   - Capability detection
   - Status tracking

2. **Symbol Distribution Engine**
   - Symbol-to-account mapping
   - Hash-based distribution
   - Manual override capability
   - Rebalancing algorithms
   - Hot symbol detection

3. **Balance Aggregator**
   - Real-time balance polling
   - Cash aggregation
   - Position consolidation
   - Buying power calculation
   - Currency conversion

4. **Account Allocator**
   - Resource-based selection
   - Round-robin with weights
   - Least-loaded selection
   - Affinity-based routing
   - Failover logic

5. **Health Monitor**
   - Connection status tracking
   - Error rate monitoring
   - Performance metrics
   - Automatic quarantine
   - Recovery detection

### Implementation Steps

1. **Design Account Model**
   - Create account entity structure
   - Define account capabilities
   - Setup status enumerations
   - Design metrics storage
   - Plan audit schema

2. **Build Registry Service**
   - Account CRUD operations
   - Credential encryption
   - Service discovery
   - Configuration management
   - Validation logic

3. **Implement Distribution**
   - Symbol assignment algorithm
   - Consistent hashing
   - Distribution rules engine
   - Migration capabilities
   - Balance optimization

4. **Create Aggregation Layer**
   - Polling scheduler
   - Data normalization
   - Cache management
   - Delta calculation
   - Event emission

5. **Develop Allocation Logic**
   - Selection algorithms
   - Weight calculation
   - Priority handling
   - Constraint validation
   - Performance optimization

6. **Add Monitoring**
   - Health check endpoints
   - Metric collection
   - Alert configuration
   - Dashboard creation
   - Report generation

## Account Management Specifications

### Account Types
```typescript
enum AccountType {
  REGULAR = 'regular',        // Standard trading account
  MARGIN = 'margin',          // Margin trading enabled
  PENSION = 'pension',        // Retirement account
  INSTITUTIONAL = 'institutional',  // High-limit account
  PAPER = 'paper'            // Testing account
}
```

### Distribution Strategies
```typescript
enum DistributionStrategy {
  HASH_BASED = 'hash',        // Consistent hash by symbol
  ROUND_ROBIN = 'round_robin', // Equal distribution
  WEIGHTED = 'weighted',       // Based on account capacity
  MANUAL = 'manual',          // Explicit assignment
  DYNAMIC = 'dynamic'         // ML-based optimization
}
```

### Account Health States
```typescript
enum AccountHealth {
  HEALTHY = 'healthy',        // Fully operational
  DEGRADED = 'degraded',      // Partial issues
  QUARANTINED = 'quarantined', // Temporarily disabled
  FAILED = 'failed',          // Connection lost
  MAINTENANCE = 'maintenance'  // Scheduled downtime
}
```

## Trading-Specific Requirements

### Symbol Distribution
- Maximum 200 symbols per account (KIS limit)
- Even distribution for load balancing
- Hot symbol isolation to dedicated accounts
- Symbol migration during rebalancing
- Sticky sessions for active positions

### Balance Management
- Real-time cash tracking
- Margin requirement calculation
- Position exposure limits
- Cross-account netting
- Settlement tracking (T+2)

### Risk Controls
- Per-account position limits
- Aggregate exposure monitoring
- Concentration risk detection
- Margin call handling
- Circuit breaker per account

### Regulatory Compliance
- Account segregation maintenance
- Beneficial ownership tracking
- Tax lot accounting per account
- Audit trail completeness
- Reporting requirements

## Performance Requirements

### Latency Targets
- Account selection: <10ms
- Balance aggregation: <50ms
- Health check: <100ms
- Symbol redistribution: <1s
- Failover detection: <5s

### Scalability
- Support 100+ accounts
- 10,000+ symbols total
- 1,000+ operations/second
- Horizontal scaling ready
- Zero-downtime updates

## Dependencies

- **2100**: Unified Broker Interface - Must conform to IBroker
- **2104**: Rate Limiting - Coordinates with rate limiter
- **2101**: KIS Integration - Primary broker implementation

## Testing Plan

- Unit tests for allocation algorithms
- Integration tests with multiple accounts
- Load distribution verification
- Failover scenario testing
- Performance benchmarks
- Symbol migration tests
- Balance reconciliation tests
- Regulatory compliance validation
- Disaster recovery drills

## Claude Code Instructions

```
When implementing this feature:
1. Use TypeScript interfaces for account contracts
2. Implement consistent hashing for symbol distribution
3. Use Redis for account state caching
4. Create NestJS modules for separation of concerns
5. Use RxJS for reactive balance updates
6. Implement saga pattern for distributed transactions
7. Add circuit breakers for account failures
8. Use event sourcing for audit trail
9. Implement CQRS for read/write separation
10. Add retry logic with exponential backoff
11. Use database transactions for critical updates
12. Implement optimistic locking for concurrent access
13. Create health check endpoints per account
14. Use feature flags for gradual rollout
15. Add comprehensive logging with correlation IDs
```

## Data Models

### Account Entity
```typescript
interface Account {
  id: string;
  broker: BrokerType;
  type: AccountType;
  credentials: EncryptedCredentials;
  status: AccountHealth;
  capabilities: AccountCapabilities;
  limits: AccountLimits;
  metrics: AccountMetrics;
  metadata: AccountMetadata;
}
```

### Symbol Assignment
```typescript
interface SymbolAssignment {
  symbol: string;
  accountId: string;
  assignedAt: Date;
  strategy: DistributionStrategy;
  weight: number;
  locked: boolean;
}
```

### Aggregated Portfolio
```typescript
interface Portfolio {
  totalCash: number;
  totalPositions: Position[];
  totalBuyingPower: number;
  accounts: AccountSummary[];
  lastUpdated: Date;
}
```

## Monitoring & Alerting

### Key Metrics
- Accounts active/total
- Symbol distribution balance
- Account utilization rates
- Failover frequency
- Balance sync latency
- Error rates per account

### Alerts
- Account connection failure
- High error rate (>5%)
- Imbalanced distribution (>20% skew)
- Low buying power
- Position limit approaching
- Sync failure

## Notes

- Consider account priorities for resource allocation
- Some accounts may have different fee structures
- Account types may have different regulatory requirements
- Symbol migration should be done during low activity
- Balance caching reduces API calls but may be stale
- Consider implementing account pools by strategy
- Hot standby accounts for critical operations

## Status Updates

- **2025-08-25**: Feature spec created and documented