# E02: Data Synchronization System - Context Log

## Spec Information
- **Spec ID**: E02
- **Title**: Data Synchronization System  
- **Type**: Epic
- **Status**: Pending

---

## Discussion Log

### 2025-09-03 - Architectural Discussion: Spec File Handling

**Participants**: User, Claude

**Key Discussion Points**:

#### 1. Spec File Parsing Ownership
**Question**: Should parsing spec files belong to JTS project or the dashboard?

**Conclusion**: Parsing should belong to JTS project.

**Rationale**:
- **Single Source of Truth**: JTS owns the spec format, structure, and parsing logic
- **Maintainability**: Changes to spec format only need updates in JTS, not dashboard
- **Clean Architecture**: Dashboard should consume processed data, not raw markdown
- **Separation of Concerns**: JTS manages specs, Dashboard visualizes them

#### 2. Spec File Access Strategy for Markdown Viewer
**Question**: How should the dashboard effectively get spec files for markdown rendering?

**Options Evaluated**:

1. **API-based approach (Recommended)**
   - JTS provides REST/GraphQL endpoints
   - Clean separation between projects
   - Enables flexible deployment

2. **GitHub Actions + CDN**
   - Specs published on merge
   - Fast, cached access via CDN
   - Good for production

3. **Shared Docker Volume (Current PRD)**
   - Read-only mount
   - Quick MVP implementation
   - Works for local development

4. **Git Submodule (Not Recommended)**
   - Too tightly coupled
   - Version sync issues

**Recommended Strategy**: Hybrid Approach
- **Phase 1 (MVP)**: Use read-only Docker volume mounting
- **Phase 2**: Transition to API-based architecture
- **Production**: Consider GitHub Actions + CDN for performance

**Key Architectural Decision**:
Dashboard should remain a pure **consumer** of spec data, maintaining clean architectural boundaries between JTS and the dashboard project.

---

## API Design Prompt for JTS Project

### Prompt: Implement Spec Data API Endpoints in JTS

**Context**: The JTS Spec Dashboard needs to consume spec data from the JTS project. To maintain clean architecture and separation of concerns, JTS should expose spec data through API endpoints rather than having the dashboard parse raw markdown files.

**Requirements**:

#### 1. Core Endpoints to Implement

```typescript
// Get list of all specs with metadata
GET /api/specs
Response: {
  specs: [{
    id: "E01",
    type: "epic",
    title: "Dashboard Core",
    status: "in_progress",
    children: ["E01-F01", "E01-F02"],
    metadata: { /* YAML frontmatter */ }
  }]
}

// Get single spec details
GET /api/specs/:id
Response: {
  id: "E01-F01",
  raw: "# Feature Title\n...",      // Raw markdown content
  rendered: "<h1>Feature...</h1>",  // HTML-rendered content
  metadata: { /* Parsed YAML */ },
  hierarchy: {
    parent: "E01",
    children: ["E01-F01-T01"]
  }
}

// Get spec hierarchy tree
GET /api/specs/tree
Response: {
  root: [{
    id: "E01",
    type: "epic",
    children: [{
      id: "E01-F01",
      type: "feature",
      children: [...]
    }]
  }]
}

// Get spec statistics
GET /api/specs/stats
Response: {
  total: { epics: 12, features: 21, tasks: 24 },
  byStatus: {
    pending: 15,
    in_progress: 10,
    completed: 20
  },
  progress: {
    overall: 44.4,
    byEpic: { "E01": 75, "E02": 0, ... }
  }
}

// Watch for changes (WebSocket/SSE)
WS /api/specs/watch
Events: {
  type: "spec_updated",
  id: "E01-F01",
  changes: { status: "completed" }
}
```

#### 2. Implementation Guidelines

- **Parsing**: Use gray-matter for YAML frontmatter extraction
- **Caching**: Implement in-memory cache for parsed specs
- **File Watching**: Use chokidar to detect spec file changes
- **Performance**: Lazy load and cache rendered HTML
- **Error Handling**: Gracefully handle malformed spec files

#### 3. Data Processing Requirements

The API should:
- Parse YAML frontmatter from all .spec.md and .context.md files
- Calculate progress percentages based on task completion
- Build hierarchical relationships from spec IDs (E01 → E01-F01 → E01-F01-T01)
- Support both raw markdown and rendered HTML responses
- Provide real-time updates via WebSocket/SSE when specs change

#### 4. Security Considerations

- Read-only access to spec files
- No modification endpoints
- Optional authentication for production deployment
- Rate limiting for public endpoints

#### 5. Development Phases

**Phase 1 (MVP)**:
- Implement basic GET endpoints for specs
- Simple file-based parsing

**Phase 2**:
- Add caching layer
- Implement WebSocket for real-time updates

**Phase 3**:
- Performance optimizations
- Advanced querying and filtering

**Expected Benefits**:
1. Dashboard becomes a pure data consumer
2. Spec format changes only require JTS updates
3. Multiple clients can consume the same API
4. Clean architectural boundaries
5. Easier testing and maintenance

**Note**: This API design allows the JTS Spec Dashboard to focus solely on visualization and user experience while JTS handles all spec management and parsing logic.

---

## Implementation Notes

- Context file created: 2025-09-03
- This epic requires coordination with JTS project for API implementation
- Dashboard should be designed to work with both direct file access (MVP) and API (future)

---

## Revision Log

### 2025-09-03 - Spec Revision: API-Based Architecture

**Changes Made to E02.spec.md**:

1. **Updated Description**: Changed from direct filesystem monitoring to API-based data consumption
   - Dashboard now acts as pure data consumer
   - No direct filesystem access to JTS specs

2. **Revised Scope**:
   - Removed: Filesystem watcher, YAML parser (moved to JTS responsibility)
   - Added: API client service, WebSocket/SSE client, local cache database
   - Focus on consuming processed data rather than parsing raw files

3. **Updated Acceptance Criteria**:
   - Changed from "detects file changes" to "receives updates via API"
   - Emphasized API-only communication (no filesystem access)
   - Reduced initial load time expectation (10s vs 30s)

4. **Revised Features**:
   - F01: ~~Filesystem Monitoring~~ → API Client Service
   - F02: ~~Spec File Parser~~ → Real-time Updates Handler
   - F03: ~~Database Schema~~ → Local Cache Database
   - F04: Synchronization Engine (updated for API sync)
   - F05: ~~Change Detection~~ → Resilience and Fallback

5. **Technical Considerations**:
   - Added phased approach: Docker volume (MVP) → API (Target)
   - Removed: chokidar, gray-matter (JTS responsibility)
   - Added: axios/fetch, Socket.io/SSE, circuit breaker pattern
   - Emphasized caching and resilience strategies

**Rationale**: Based on architectural discussion, parsing and spec management belongs to JTS project. Dashboard should focus on visualization and consume processed data via APIs. This maintains clean separation of concerns and single source of truth.